<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `aggregate` mod in crate `bellperson`."><title>bellperson::groth16::aggregate - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bellperson" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../bellperson/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../bellperson/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module aggregate</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">bellperson</a>::<wbr><a href="../index.html">groth16</a>::<wbr><a class="mod" href="#">aggregate</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/bellperson/groth16/aggregate/mod.rs.html#1-69">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AggregateProof.html" title="struct bellperson::groth16::aggregate::AggregateProof">AggregateProof</a></div><div class="desc docblock-short">AggregateProof contains all elements to verify n aggregated Groth16 proofs
using inner pairing product arguments. This proof can be created by any
party in possession of valid Groth16 proofs.</div></li><li><div class="item-name"><a class="struct" href="struct.AggregateProofAndInstance.html" title="struct bellperson::groth16::aggregate::AggregateProofAndInstance">AggregateProofAndInstance</a></div></li><li><div class="item-name"><a class="struct" href="struct.GenericSRS.html" title="struct bellperson::groth16::aggregate::GenericSRS">GenericSRS</a></div><div class="desc docblock-short">It contains the maximum number of raw elements of the SRS needed to aggregate and verify
Groth16 proofs. One can derive specialized prover and verifier key for <em>specific</em> size of
aggregations by calling <code>srs.specialize(n)</code>. The specialized prover key also contains
precomputed tables that drastically increase prover’s performance.
This GenericSRS is usually formed from the transcript of two distinct power of taus ceremony
,in other words from two distinct Groth16 CRS.
See <a href="https://github.com/nikkolasg/taupipp">there</a> a way on how to generate this GenesisSRS.</div></li><li><div class="item-name"><a class="struct" href="struct.GipaProof.html" title="struct bellperson::groth16::aggregate::GipaProof">GipaProof</a></div><div class="desc docblock-short">It contains all elements derived in the GIPA loop for both TIPP and MIPP at
the same time.</div></li><li><div class="item-name"><a class="struct" href="struct.Key.html" title="struct bellperson::groth16::aggregate::Key">Key</a></div><div class="desc docblock-short">Key is a generic commitment key that is instanciated with g and h as basis,
and a and b as powers.</div></li><li><div class="item-name"><a class="struct" href="struct.ProverSRS.html" title="struct bellperson::groth16::aggregate::ProverSRS">ProverSRS</a></div><div class="desc docblock-short">ProverSRS is the specialized SRS version for the prover for a specific number of proofs to
aggregate. It contains as well the commitment keys for this specific size.
Note the size must be a power of two for the moment - if it is not, padding must be applied.</div></li><li><div class="item-name"><a class="struct" href="struct.ProverSRSInputAggregation.html" title="struct bellperson::groth16::aggregate::ProverSRSInputAggregation">ProverSRSInputAggregation</a></div><div class="desc docblock-short">ProverSRS is the specialized SRS version for the prover for a specific number of proofs to
aggregate. It contains as well the commitment keys for this specific size.
Note the size must be a power of two for the moment - if it is not, padding must be applied.</div></li><li><div class="item-name"><a class="struct" href="struct.TippMippProof.html" title="struct bellperson::groth16::aggregate::TippMippProof">TippMippProof</a></div><div class="desc docblock-short">It contains the GIPA recursive elements as well as the KZG openings for v
and w</div></li><li><div class="item-name"><a class="struct" href="struct.VerifierSRS.html" title="struct bellperson::groth16::aggregate::VerifierSRS">VerifierSRS</a></div><div class="desc docblock-short">Contains the necessary elements to verify an aggregated Groth16 proof; it is of fixed size
regardless of the number of proofs aggregated. However, a verifier SRS will be determined by
the number of proofs being aggregated.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AggregateVersion.html" title="enum bellperson::groth16::aggregate::AggregateVersion">AggregateVersion</a></div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.MAX_SRS_SIZE.html" title="constant bellperson::groth16::aggregate::MAX_SRS_SIZE">MAX_SRS_SIZE</a></div><div class="desc docblock-short">Maximum size of the generic SRS constructed from Filecoin and Zcash power of
taus.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.aggregate_proofs.html" title="fn bellperson::groth16::aggregate::aggregate_proofs">aggregate_proofs</a></div><div class="desc docblock-short">Aggregate <code>n</code> zkSnark proofs, where <code>n</code> must be a power of two.
WARNING: transcript_include represents everything that should be included in
the transcript from outside the boundary of this function. This is especially
relevant for ALL public inputs of ALL individual proofs. In the regular case,
one should input ALL public inputs from ALL proofs aggregated. However, IF ALL the
public inputs are <strong>fixed, and public before the aggregation time</strong>, then there is
no need to hash those. The reason we specify this extra assumption is because hashing
the public inputs from the decoded form can take quite some time depending on the
number of proofs and public inputs (+100ms in our case). In the case of Filecoin, the only
non-fixed part of the public inputs are the challenges derived from a seed. Even though this
seed comes from a random beeacon, we are hashing this as a safety precaution.</div></li><li><div class="item-name"><a class="fn" href="fn.aggregate_proofs_and_instances.html" title="fn bellperson::groth16::aggregate::aggregate_proofs_and_instances">aggregate_proofs_and_instances</a></div></li><li><div class="item-name"><a class="fn" href="fn.pair.html" title="fn bellperson::groth16::aggregate::pair">pair</a></div><div class="desc docblock-short">Commits to a tuple of G1 vector and G2 vector in the following way:
$T = \prod_{i=0}^n e(A_i, v_{1,i})e(B_i,w_{1,i})$
$U = \prod_{i=0}^n e(A_i, v_{2,i})e(B_i,w_{2,i})$
Output is $(T,U)$</div></li><li><div class="item-name"><a class="fn" href="fn.setup_fake_srs.html" title="fn bellperson::groth16::aggregate::setup_fake_srs">setup_fake_srs</a></div></li><li><div class="item-name"><a class="fn" href="fn.single_g1.html" title="fn bellperson::groth16::aggregate::single_g1">single_g1</a></div><div class="desc docblock-short">Commits to a single vector of G1 elements in the following way:
$T = \prod_{i=0}^n e(A_i, v_{1,i})$
$U = \prod_{i=0}^n e(A_i, v_{2,i})$
Output is $(T,U)$</div></li><li><div class="item-name"><a class="fn" href="fn.verify_aggregate_proof.html" title="fn bellperson::groth16::aggregate::verify_aggregate_proof">verify_aggregate_proof</a></div><div class="desc docblock-short">Verifies the aggregated proofs thanks to the Groth16 verifying key, the
verifier SRS from the aggregation scheme, all the public inputs of the
proofs and the aggregated proof.</div></li><li><div class="item-name"><a class="fn" href="fn.verify_aggregate_proof_and_aggregate_instances.html" title="fn bellperson::groth16::aggregate::verify_aggregate_proof_and_aggregate_instances">verify_aggregate_proof_and_aggregate_instances</a></div><div class="desc docblock-short">verification of related instances i.e. when instances are given by
[a1, … , an, b1, … , bn], [b1, … , bn, c1, …, cn], [c1, …, cn, d1, …, dn] etc</div></li><li><div class="item-name"><a class="fn" href="fn.verify_kzg_v.html" title="fn bellperson::groth16::aggregate::verify_kzg_v">verify_kzg_v</a></div><div class="desc docblock-short">verify_kzg_opening_g2 takes a KZG opening, the final commitment key, SRS and
any shift (in TIPP we shift the v commitment by r^-1) and returns a pairing
tuple to check if the opening is correct or not.</div></li><li><div class="item-name"><a class="fn" href="fn.verify_kzg_w.html" title="fn bellperson::groth16::aggregate::verify_kzg_w">verify_kzg_w</a></div><div class="desc docblock-short">Similar to verify_kzg_opening_g2 but for g1.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.KZGOpening.html" title="type bellperson::groth16::aggregate::KZGOpening">KZGOpening</a></div><div class="desc docblock-short">KZGOpening represents the KZG opening of a commitment key (which is a tuple
given commitment keys are a tuple).</div></li><li><div class="item-name"><a class="type" href="type.Output.html" title="type bellperson::groth16::aggregate::Output">Output</a></div><div class="desc docblock-short">Both commitment outputs a pair of $F_q^k$ element.</div></li><li><div class="item-name"><a class="type" href="type.VKey.html" title="type bellperson::groth16::aggregate::VKey">VKey</a></div><div class="desc docblock-short">Commitment key used by the “single” commitment on G1 values as
well as in the “pair” commtitment.
It contains ${h^a^i}<em>{i=1}^n$ and ${h^b^i}</em>{i=1}^n$</div></li><li><div class="item-name"><a class="type" href="type.WKey.html" title="type bellperson::groth16::aggregate::WKey">WKey</a></div><div class="desc docblock-short">Commitment key used by the “pair” commitment. Note the sequence of
powers starts at $n$ already.
It contains ${g^{a^{n+i}}}<em>{i=1}^n$ and ${g^{b^{n+i}}}</em>{i=1}^n$</div></li></ul></section></div></main></body></html>